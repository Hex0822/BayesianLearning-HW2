RWMsampler <- function(logPostFunc, initVal, nSim, nBurn, Sigma, c, ...){
nIter = nSim + nBurn
p = length(initVal)
theta = matrix(NA, nrow=nIter, ncol=p)
theta[1, ] = initVal
logPostPrev = logPostFunc(initVal, ...)
accept = 0
# Run the algorithm for nSim+nBurn iterations
for (i in 2:nIter){
# using the multivariate proposal N(theta_previous_draw, c*Sigma)
thetaStar = as.vector(rmvnorm(1, mean = theta[i-1, ], sigma = c * Sigma))
logPostStar = logPostFunc(thetaStar, ...)
logPostRatio = logPostStar - logPostPrev
alpha = min(1, exp(logPostRatio))
u = runif(1)
# accept and update if u <= alpha
if (u < alpha){
theta[i, ] = thetaStar
logPostPrev = logPostStar
accept = accept + 1
}
# reject and stay if u > alpha
else{
theta[i, ] = theta[i-1, ]
}
}
# Return the posterior draws after discarding nBurn iterations as burn-in
draws = theta[(nBurn+1):nIter, ]
accept_ratio = accept/nIter
return(list(
draws = draws,
accept_ratio = accept_ratio
))
}
# settings for RWMsampler
LogPostPois = function(betaVec, x, y, mu, omega){
Logprior = dmvnorm(betaVec, mean=mu, sigma=omega, log=TRUE)
lambda_i = exp(x %*% betaVec)
Loglik = sum(dpois(y,lambda=lambda_i,log=TRUE))
Logpost = Loglik + Logprior
return(Logpost)
}
Sigma = postCov
c = 0.5
nSim = 5000
nBurn = 1000
initVal = c(0,0,0,0,0)
RWM_draws = RWMsampler(LogPostPois, initVal, nSim, nBurn, Sigma, c, x=X, y=y,
mu=mu0, omega=Omega)
RWM_draws$accept_ratio
par(mfrow=c(2, 3))
for (i in 1:ncol(RWM_draws$draws)){
hist(RWM_draws$draws[, i], breaks=50, freq=FALSE, col="lightblue",
ylab="Marginal Posterior Density", main=coef_names[i],
xlab=bquote(beta[.(i-1)])
)
}
post_draws = RWM_draws$draws
par(mfrow = c(2, 3))
for (i in 1:ncol(post_draws)) {
plot(post_draws[, i], type = "l",
main = coef_names[i],
xlab = "Iterations",
ylab = bquote(beta[.(i-1)]))
}
par(mfrow = c(2, 3))
post_draws_mean = numeric(length(initVal))
for (i in 1:ncol(post_draws)) {
cum_mean = cumsum(post_draws[, i]) / seq_along(post_draws[, i])
plot(cum_mean, type = "l",
main = coef_names[i],
xlab = "Iteration",
ylab = bquote(beta[.(i-1)]))
post_mean = mean(post_draws[, i])
post_draws_mean[i] = post_mean
abline(h = post_mean, col = "red", lwd = 2, lty = 2)
}
unit_initVal = c(1,1,1,1,1)
RWM_draws_unit = RWMsampler(LogPostPois, unit_initVal, nSim, nBurn, Sigma, c,
x=X, y=y, mu=mu0, omega=Omega)
RWM_draws_unit$accept_ratio
par(mfrow=c(2, 3))
post_draws_unit = RWM_draws_unit$draws
post_draws_unit_mean = numeric(length(unit_initVal))
for (i in 1:ncol(post_draws_unit)){
cum_mean_unit = cumsum(post_draws_unit[, i]) / seq_along(post_draws_unit[, i])
plot(cum_mean_unit, type="l", main=coef_names[i],
xlab="Iteration", ylab=bquote(beta[.(i-1)]))
post_mean = mean(post_draws_unit[, i])
post_draws_unit_mean[i] = post_mean
abline(h = post_mean, col="blue", lwd=2, lty=2)
}
post_draws_summary = data.frame(
Parameters = coef_names,
Zero_initVal_Esitimate = post_draws_mean,
Unit_initVal_Esitimate = post_draws_unit_mean
)
post_draws_summary
p = ncol(X)
Sigma_new = diag(p)
c_new = 1
initVal = c(0, 0, 0, 0, 0)
RWM_draws_new = RWMsampler(LogPostPois, initVal, nSim, nBurn, Sigma_new, c_new,
x=X, y=y, mu=mu0, omega=Omega)
RWM_draws_new$accept_ratio
par(mfrow=c(2, 3))
post_draws_new = RWM_draws_new$draws
for (i in 1:ncol(post_draws_new)){
cum_mean_new = cumsum(post_draws_new[, i]) / seq_along(post_draws_new[, i])
plot(cum_mean_new, type="l", main=coef_names[i],
xlab="Iteration", ylab=bquote(beta[.(i-1)]))
post_mean = mean(post_draws_new[, i])
abline(h = post_mean, col="steelblue", lwd=2, lty=2)
}
library(rstan)
library(loo)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
set.seed(42)
# beta prior setting
p = 5
tau = 10
I_p = diag(5)
Omega = tau^2 * I_p
mu0 = as.vector(rep(0, p))
n = nrow(X)
y = data$nBugs
post_stan = "
data {
int<lower=0> n;
int<lower=0> y[n];
int<lower=1> p;
matrix[n, p] X;
real<lower=0> tau;
}
parameters {
vector[p] beta;
}
model {
beta ~ normal(0, tau); // prior
y ~ poisson_log(X * beta); // likelihood
}
"
fit = stan(
model_code = post_stan,
data = list(n=n, y=y, p=p, X=X, tau=tau),
chains=4, warmup=1000, iter=2000, seed=42,
control=list(adapt_delta=0.95)
)
traceplot(fit)
print(fit, pars = "beta")
beta_post = extract(fit, par = "beta")
par(mfrow=c(2, 3))
for (i in 1:p){
hist(beta_post$beta[, i],
main = coef_names[i],
xlab = bquote(beta[.(i-1)]),
col = "lightblue",
freq=FALSE, breaks=50)
}
plot(fit, pars = "beta")
xNew = c(1, 10, 0.45, 0.5, 0.89)
set.seed(42)
# beta prior setting
p = 5
tau = 10
I_p = diag(5)
Omega = tau^2 * I_p
mu0 = as.vector(rep(0, p))
n = nrow(X)
y = data$nBugs
X_new = matrix(xNew, nrow=1)
post_stan_pred = "
data {
int<lower=0> n;
int<lower=0> y[n];
int<lower=1> p;
matrix[n, p] X;
real<lower=0> tau;
int<lower=0> N_new;
matrix[N_new, p] X_new;
}
parameters {
vector[p] beta;
}
model {
beta ~ normal(0, tau); // prior
y ~ poisson_log(X * beta); // likelihood/model
}
generated quantities{
vector[N_new] y_new;
for (i in 1:N_new){
y_new[i] = poisson_log_rng(dot_product(X_new[i], beta)); // predictive model
}
}
"
fit_pred = stan(
model_code = post_stan_pred,
data = list(n=n, y=y, p=p, X=X, tau=tau, N_new=1, X_new=X_new),
chains=4, warmup=1000, iter=2000, seed=42,
control=list(adapt_delta=0.95)
)
#install.packages("HDInterval")
library(HDInterval)
pred_post_y_new = extract(fit_pred)$y_new
#y_pred_tab = table(pred_post_y_new)
#y_pred_mode = as.numeric(names(y_pred_tab[which.max(y_pred_tab)]))
y_pred_mean = mean(pred_post_y_new)
HPD_interval = hdi(pred_post_y_new, 0.95)
hist(pred_post_y_new, breaks = 30, freq=FALSE,
col="lightblue",
main = "Posterior Predictive Distribution for The Number of Bugs",
xlab = "Predicted number of bugs")
abline(v=y_pred_mean, col="red", lty=2, lwd=2)
abline(v=HPD_interval[1], col="red", lty=1, lwd=2)
abline(v=HPD_interval[2], col="red", lty=1, lwd=2)
legend(
"topright",
legend = c(paste0("y_pred_mean = ", y_pred_mean),
paste0("HPD lower = ", HPD_interval[1]),
paste0("HPD upper = ", HPD_interval[2])),
col = "red",
lwd = 2,
lty = 2,
bty = "n"
)
# settings for Stan
post_stan_nb = "
data {
int<lower=0> n;
int<lower=0> y[n];
int<lower=1> p;
matrix[n, p] X;
real<lower=0> tau;
}
parameters {
vector[p] beta;
real<lower=0> r;
}
model {
beta ~ normal(0, tau); //prior
r ~ exponential(1); //prior
y ~ neg_binomial_2_log(X * beta, r); //likelihood/model
}
"
fit_nb = stan(
model_code = post_stan_nb,
data = list(n=n, y=y, p=p, X=X, tau=tau),
chains = 4, warmup=1000, iter = 2000, seed = 42,
control=list(adapt_delta=0.95)
)
traceplot(fit_nb)
traceplot(fit_nb)
traceplot(fit_nb)
print(fit_nb, par=c("beta", "r"))
print(fit_nb, par=c("beta", "r"))
traceplot(fit_nb)
post_draws_nb = extract(fit_nb)
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue")
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
main="Posterior of overdispersion parameter r")
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
main="Posterior of Overdispersion Parameter r")
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="")
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="Overdispersion")
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="Overdispersion")
abline(v = mean(post_draws_nb$r), col="darkred", lwd=2)
text(mean(post_draws_nb$r), 0, labels="mean(r)", pos=4, col="darkred", cex=0.8)
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="Overdispersion")
abline(v = mean(post_draws_nb$r), col="red", lty=2, lwd=2)
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="Overdispersion")
abline(v = mean(post_draws_nb$r), col="red", lty=2, lwd=2)
legend()
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="Overdispersion")
abline(v = mean(post_draws_nb$r), col="red", lty=2, lwd=2)
legend("topright",
legend=paste0("r_mean = ", ,mean(post_draws_nb$r)),
col="red",
lwd=2,
lty=2,
bty="n")
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="Overdispersion")
abline(v = mean(post_draws_nb$r), col="red", lty=2, lwd=2)
legend("topright",
legend=paste0("r_mean = ", mean(post_draws_nb$r)),
col="red",
lwd=2,
lty=2,
bty="n")
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="Overdispersion")
abline(v = mean(post_draws_nb$r), col="red", lty=2, lwd=2)
legend("topright",
legend=paste0("r_mean = ", round(mean(post_draws_nb$r)), 4),
col="red",
lwd=2,
lty=2,
bty="n")
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="Overdispersion")
abline(v = mean(post_draws_nb$r), col="red", lty=2, lwd=2)
legend("topright",
legend=paste0("r_mean = ", round(mean(post_draws_nb$r)), 2),
col="red",
lwd=2,
lty=2,
bty="n")
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="Overdispersion")
abline(v = mean(post_draws_nb$r), col="red", lty=2, lwd=2)
legend("topright",
legend=paste0("r_mean = ", mean(post_draws_nb$r)),
col="red",
lwd=2,
lty=2,
bty="n")
post_draws_nb = extract(fit_nb)
hist(post_draws_nb$r, col="lightblue",
freq=FALSE,
main="Posterior of Overdispersion Parameter r",
xlab="Overdispersion")
abline(v = mean(post_draws_nb$r), col="red", lty=2, lwd=2)
legend("topright",
legend=paste0("r_mean = ", mean(post_draws_nb$r)),
col="red",
lwd=2,
lty=2,
bty="n")
set.seed(42)
# beta prior setting
p = 5
tau = 10
I_p = diag(5)
Omega = tau^2 * I_p
mu0 = as.vector(rep(0, p))
n = nrow(X)
y = data$nBugs
X_new = matrix(xNew, nrow=1)
post_stan_pred = "
data {
int<lower=0> n;
int<lower=0> y[n];
int<lower=1> p;
matrix[n, p] X;
real<lower=0> tau;
int<lower=0> N_new;
matrix[N_new, p] X_new;
}
parameters {
vector[p] beta;
}
model {
beta ~ normal(0, tau); // prior
y ~ poisson_log(X * beta); // likelihood/model
}
generated quantities{
vector[N_new] y_new;
for (i in 1:N_new){
y_new[i] = poisson_log_rng(dot_product(X_new[i], beta)); // predictive model
}
}
"
fit_pred = stan(
model_code = post_stan_pred,
data = list(n=n, y=y, p=p, X=X, tau=tau, N_new=1, X_new=X_new),
chains=4, warmup=1000, iter=2000, seed=42,
control=list(adapt_delta=0.95)
)
set.seed(42)
# beta prior setting
p = 5
tau = 10
I_p = diag(5)
Omega = tau^2 * I_p
mu0 = as.vector(rep(0, p))
n = nrow(X)
y = data$nBugs
X_new = matrix(xNew, nrow=1)
post_stan_pred = "
data {
int<lower=0> n;
int<lower=0> y[n];
int<lower=1> p;
matrix[n, p] X;
real<lower=0> tau;
int<lower=0> N_new;
matrix[N_new, p] X_new;
}
parameters {
vector[p] beta;
}
model {
beta ~ normal(0, tau); // prior
y ~ poisson_log(X * beta); // likelihood/model
}
generated quantities{
vector[N_new] y_new;
for (i in 1:N_new){
y_new[i] = poisson_log_rng(X_new[i] %*% beta); // predictive model
}
}
"
fit_pred = stan(
model_code = post_stan_pred,
data = list(n=n, y=y, p=p, X=X, tau=tau, N_new=1, X_new=X_new),
chains=4, warmup=1000, iter=2000, seed=42,
control=list(adapt_delta=0.95)
)
set.seed(42)
# beta prior setting
p = 5
tau = 10
I_p = diag(5)
Omega = tau^2 * I_p
mu0 = as.vector(rep(0, p))
n = nrow(X)
y = data$nBugs
X_new = matrix(xNew, nrow=1)
post_stan_pred = "
data {
int<lower=0> n;
int<lower=0> y[n];
int<lower=1> p;
matrix[n, p] X;
real<lower=0> tau;
int<lower=0> N_new;
matrix[N_new, p] X_new;
}
parameters {
vector[p] beta;
}
model {
beta ~ normal(0, tau); // prior
y ~ poisson_log(X * beta); // likelihood/model
}
generated quantities{
vector[N_new] y_new;
for (i in 1:N_new){
y_new[i] = poisson_log_rng(dot_product(X_new[i], beta)); // predictive model
}
}
"
fit_pred = stan(
model_code = post_stan_pred,
data = list(n=n, y=y, p=p, X=X, tau=tau, N_new=1, X_new=X_new),
chains=4, warmup=1000, iter=2000, seed=42,
control=list(adapt_delta=0.95)
)
#install.packages("HDInterval")
library(HDInterval)
pred_post_y_new = extract(fit_pred)$y_new
#y_pred_tab = table(pred_post_y_new)
#y_pred_mode = as.numeric(names(y_pred_tab[which.max(y_pred_tab)]))
y_pred_mean = mean(pred_post_y_new)
HPD_interval = hdi(pred_post_y_new, 0.95)
hist(pred_post_y_new, breaks = 30, freq=FALSE,
col="lightblue",
main = "Posterior Predictive Distribution for The Number of Bugs",
xlab = "Predicted number of bugs")
abline(v=y_pred_mean, col="red", lty=2, lwd=2)
abline(v=HPD_interval[1], col="red", lty=1, lwd=2)
abline(v=HPD_interval[2], col="red", lty=1, lwd=2)
legend(
"topright",
legend = c(paste0("y_pred_mean = ", y_pred_mean),
paste0("HPD lower = ", HPD_interval[1]),
paste0("HPD upper = ", HPD_interval[2])),
col = "red",
lwd = 2,
lty = 2,
bty = "n"
)
